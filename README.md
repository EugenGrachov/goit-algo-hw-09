# Звіт по домашньому завданню: Пошук мінімальної кількості монет для решти

## Опис домашнього завдання
У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

##  Функція жадібного алгоритму find_coins_greedy.
  Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

##  Функція динамічного програмування find_min_coins.
  Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}
Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл readme.md домашнього завдання.

## Результати експериментів

Запуск обох алгоритмів було проведено для різних значень суми. Час виконання (у секундах) та розподіл монет наведені нижче:

| Сума   | Жадібний алгоритм (сек) | Монети (жадібний)                       | ДП алгоритм (сек) | Монети (ДП)                              |
|--------|-------------------------|-----------------------------------------|-------------------|-----------------------------------------|
| 1      | 0.0000034               | {1:1}                                  | 0.0000079         | {1:1}                                  |
| 113    | 0.0000016               | {50:2, 10:1, 2:1, 1:1}                 | 0.000036          | {50:2, 10:1, 2:1, 1:1}                 |
| 99     | 0.0000011               | {50:1, 25:1, 10:2, 2:2}                | 0.0000563         | {50:1, 25:1, 10:2, 2:2}                |
| 1234   | 0.0000032               | {50:24, 25:1, 5:1, 2:2}                | 0.0003766         | {50:24, 25:1, 5:1, 2:2}                |
| 20     | 0.0000012               | {10:2}                                 | 0.0000087         | {10:2}                                 |
| 99999  | 0.0000021               | {50:1999, 25:1, 10:2, 2:2}             | 0.0341153         | {50:1999, 25:1, 10:2, 2:2}             |
| 37     | 0.0000048               | {25:1, 10:1, 2:1}                      | 0.0000185         | {25:1, 10:1, 2:1}                      |

## Аналіз та висновки

1. **Часова складність**:
   - Жадібний алгоритм виконується дуже швидко — його складність приблизно O(n), де n — кількість номіналів, адже він просто перебирає монети від найбільшої до найменшої.
   - Алгоритм динамічного програмування має складність O(amount * n), де amount — сума, а n — кількість номіналів. Це помітно уповільнює його виконання при великих сумах (наприклад, для 99999 час зріс до ~0.03 с).

2. **Оптимальність рішення**:
   - Для цього набору монет жадібний алгоритм завжди знаходить мінімальну кількість монет. Це пов’язано з властивостями номіналів (їх співвідношення дає змогу використовувати жадібний підхід без помилок).
   - Алгоритм динамічного програмування теж знаходить мінімальний набір монет, але працює повільніше.

3. **Вибір алгоритму**:
   - Для касового апарату, де важлива швидкість, жадібний алгоритм є найбільш підходящим рішенням.
   - Якщо набір монет не є «стандартним» (наприклад, номінали довільні, і жадібний алгоритм може дати не оптимальний результат), тоді слід використовувати алгоритм динамічного програмування.
   - При дуже великих сумах і складних наборах монет треба зважати на компроміс між часом та оптимальністю.

